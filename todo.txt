[ ] Implement some kind of messaging system where objects can notify the player he's dead
    Can go with this sort of structure first. If it turns out that it is more elegant to just
    handle everything at the level of the world or player or playstate, then we can switch to
    that.

    Advantages of per-item check and then call:
    - More generic -- the items can send out whatever signal is needed, and the PlayState
        processes those signals appropriately. This keeps objects in the world fairly lightweight
        and keeps the actual logic of the game in PlayState.

    Performing checks in PlayState:
    - Basically, the Player tells PlayState whether it's touching something like spikes or a lever,
    or hitting "e" when interacting with something. Then PlayState handles all of that logic.

    So it seems like it's a battle between having each item send out their signals to the PlayState,
    or instead having all of the checking logic inside of player and PlayState.

    One benefit of having the logic inside the items themselves, is that it might make it easier
    to implement environment-environment interactions later on.

---

There's a few things we need to do right now.

1. Set up a system with which the player can interact with levers in order to toggle the floors on or off.
2. Should this ideally be the same system that handles killing the player if they touch a spike?

== 13 October 2022 ===

Need to figure out how to perform the drawing stuff properly.

Current progress:

    type PauseScene struct {
        assets Assets
        // ebitenImage *ebiten.Image
    }

    func (s *PauseScene) Update(state *GameState) error {
        if inpututil.IsKeyJustPressed(ebiten.KeyEscape) {
            state.SceneManager.pop()
        }
        return nil
    }

    func (s *PauseScene) Draw(screen *ebiten.Image) {
        ebitenutil.DebugPrint(screen, "=== PAUSE SCREEN ===")
        for i := 0; i < 5; i++ {
            s.assets.qdraw(screen, i, float64(i)*16, 16)
        }

        // for i := range s.assets.quads {
        //  multiplier := float64(i)
        //  op := &ebiten.DrawImageOptions{}
        //  op.GeoM.Translate(multiplier*10.0, multiplier*10.0)
        //  s.assets.qdraw(screen, i, multiplier*10, multiplier*10)
        //  // screen.DrawImage(s.assets.quads[i].(*ebiten.Image), op)
        // }
        // // Scratch
        // for i := 0; i < 10; i++ {
        //  m := float64(i)
        //  op := &ebiten.DrawImageOptions{}
        //  op.GeoM.Translate(m*16, m*16)
        //  screen.DrawImage(s.ebitenImage.SubImage(image.Rect(int(m*16), int(m*16), 16, 16)).(*ebiten.Image), op)
        // }

        // op := &ebiten.DrawImageOptions{}
        // op.GeoM.Translate(10, 10)
        // screen.DrawImage(s.ebitenImage.SubImage(image.Rect(0, 32, 16, 16)).(*ebiten.Image), op)
    }

    func (s *PauseScene) init() {
        // ebitenImage, err := getEbitenImage("tex.png")
        // if err != nil {
        //  fmt.Println(err)
        // }
        // s.ebitenImage = ebitenImage
        fmt.Println("initializing assets...")
        s.assets.init()
    }

    func (s *PauseScene) trigger(msg string) {}

    type Assets struct {
        // tex *ebiten.Image
        // quads []*image.Image
        // quads []*ebiten.Image
    }

    func (a Assets) qdraw(screen *ebiten.Image, id int, x float64, y float64) {
        tex, err := getEbitenImage("tex.png")
        if err != nil {
            fmt.Println("ERROR!!! ")
            fmt.Println(err)
        }
        // Grab image id from tex
        op := &ebiten.DrawImageOptions{}
        op.GeoM.Translate(x, y)
        texWidth, texHeight := tex.Size()
        // id := 0
        ctr := 0
        for y := 0; y < texHeight; y = y + 16 {
            for x := 0; x < texWidth; x = x + 16 {
                ctr++
                if ctr == id {
                    screen.DrawImage(tex.SubImage(image.Rect(x, y, 16, 16)).(*ebiten.Image), op)
                }
                // img := tex.SubImage(image.Rect(x, y, 16, 16)).(*ebiten.Image)
                // a.quads = append(a.quads, img)
            }
        }
        // screen.DrawImage(a.quads[id], op)
        // screen.DrawImage(s.ebitenImage.SubImage(image.Rect(0, 32, 16, 16)).(*ebiten.Image), op)
    }

    func (a Assets) init() error {
        // a.quads = []*ebiten.Image{}
        // Pull in atlas
        asdf, err := getEbitenImage("tex.png")
        if err != nil {
            return err
        }
        a.tex = asdf
        // a.tex = tex
        // 64 width, 96 height
        // // Pull out quads
        // texWidth, texHeight := tex.Size()
        // for y := 0; y < texHeight; y = y + 16 {
        //  for x := 0; x < texWidth; x = x + 16 {
        //      img := tex.SubImage(image.Rect(x, y, 16, 16)).(*ebiten.Image)
        //      a.quads = append(a.quads, img)
        //  }
        // }
        return nil
    }


But lots of pointer errors.



